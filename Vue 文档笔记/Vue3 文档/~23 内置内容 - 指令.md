[TOC]

# [内置指令](https://cn.vuejs.org/api/built-in-directives.html#%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4)

## v-if

基于表达式值的真假性，来条件性地渲染元素或者模板片段。

- **期望的绑定值类型：**`any`

- **详细信息**

  当 `v-if` 元素被触发，元素及其所包含的指令/组件都会销毁和重构。如果初始条件是假，那么其内部的内容根本都不会被渲染。

  可用于 `<template>` 表示仅包含文本或多个元素的条件块。

  当**条件改变时会触发过渡效果**。

  当同时使用时，**`v-if` 比 `v-for` 优先级更高**。

  >  我们并不推荐在一元素上同时使用这两个指令 — 查看[列表渲染指南](https://cn.vuejs.org/guide/essentials/list.html#v-for-with-v-if)详情。



## v-memo [# 3.2+](https://cn.vuejs.org/api/built-in-directives.html#v-memo)

- **期望的绑定值类型：**`any[]`

- **详细信息**

  **缓存一个模板的子树**。在元素和组件上都可以使用。

  为了实现缓存，该指令需要传入一个**固定长度的依赖值数组**进行比较。

  如果数组里的每个值都与最后一次的渲染相同，那么**整个子树的更新将被跳过**。举例来说：

```vue
<div v-memo="[valueA, valueB]">
  ...
</div>
```

当组件重新渲染，如果 `valueA` 和 `valueB` 都保持不变，这个 `<div>` 及其子项的所有更新都将被跳过。

实际上，甚至**虚拟 DOM 的 vnode 创建也将被跳过**，因为缓存的子树副本可以被重新使用。

**正确指定缓存数组很重要，否则应该生效的更新可能被跳过。**

`v-memo` 传入空依赖数组 (`v-memo="[]"`) 将与 `v-once` 效果相同。



**与 `v-for` 一起使用**

>  `v-memo` 仅用于性能至上**场景中的微小优化，应该很少需要**。最常见的情况可能是有助于**渲染海量 `v-for` 列表** (长度超过 1000 的情况)

```vue
<div v-for="item in list" :key="item.id" v-memo="[item.id === selected]">
  <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>
  <p>...more child nodes</p>
</div>
```

当组件的 `selected` 状态改变，默认会重新创建大量的 vnode，尽管绝大部分都跟之前是一模一样的。

`v-memo` 用在这里本质上是在说“只有当该项的被选中状态改变时才需要更新”。这使得每个选中状态没有变的项能完全重用之前的 vnode 并跳过差异比较。

注意这里 memo 依赖数组中并不需要包含 `item.id`，因为 Vue 也会根据 item 的 `:key` 进行判断。

> 当搭配 `v-for` 使用 `v-memo`，确保两者都绑定在同一个元素上。
>
> **`v-memo` 不能用在 `v-for` 内部。**

`v-memo` 也能被用于在一些默认优化失败的边际情况下，手动避免子组件出现不需要的更新。但是一样的，开发者需要负责指定正确的依赖数组以免跳过必要的更新。